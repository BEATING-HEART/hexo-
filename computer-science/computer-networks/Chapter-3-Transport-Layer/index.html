<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑄日" href="http://blog.sunforge.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑄日" href="http://blog.sunforge.cn/atom.xml"><link rel="alternate" type="application/json" title="鑄日" href="http://blog.sunforge.cn/feed.json"><link rel="stylesheet" href="//fonts.sourcegcdn.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="http://blog.sunforge.cn/computer-science/computer-networks/Chapter-3-Transport-Layer/"><title>Chapter 3 Transport Layer - 计算机网络 - 计算机科学 | Sunforge = 鑄日 = 浩蕩長夜 至此而終</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Chapter 3 Transport Layer</h1><div class="meta"><span class="item" title="创建时间：2022-09-11 13:05:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-11T13:05:52+08:00">2022-09-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sunforge</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="item" rel="index" title="分类于 计算机网络"><span itemprop="name">计算机网络</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.sunforge.cn/computer-science/computer-networks/Chapter-3-Transport-Layer/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sunforge"><meta itemprop="description" content="浩蕩長夜 至此而終, 计科人笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑄日"></span><div class="body md" itemprop="articleBody"><h1 id="传输层原理"><a class="anchor" href="#传输层原理">#</a> 传输层原理</h1><p>传输层，不管是 TCP 还是 UDP，会同时支撑很多应用进程。源端<strong>如何复用</strong>，目标端如何解复用还给相应的进程？</p><p><strong>可靠数据传输原理 RDT</strong>：非常经典、重要。下层 IP 是不可靠的，但 TCP 如何向上层提供可靠服务？为什么会不可靠，要引入什么机制保证可靠？</p><p><strong>流量控制</strong>：TCP 和对等的 TCP 实体怎么协作，实现流量控制，以至于不会发送太快，从而超出接收方的处理能力。</p><p><strong>拥塞控制</strong>：如果发送方和接受方的处理速度都足够快，但是网络路径上有拥塞，那么就需要有一个拥塞的感知，然后恢复出来。如果没有拥塞控制的机制，那么网络几乎无法使用。<strong>学习：原因、表现、检测、控制</strong></p><h1 id="概述和传输层服务"><a class="anchor" href="#概述和传输层服务">#</a> 概述和传输层服务</h1><p>传输层向上层提供的是进程与进程之间的，以 message 报文为单位的，逻辑的通信。</p><p><strong>报文的传输</strong>：应用层交给传输层的报文，<strong>如果比较长，会被分成若干个报文段</strong>。以段为单位，形成本层的 PDU（协议数据单元）。到对方，对方把头部去掉，然后把段的内容取出来，以字节流的形式交给上面的应用进程。（借助网络层的服务）</p><p>** 可靠性、安全性可以在传输层加强。延迟、带宽不可以在传输层优化。** 瓶颈式的链路制约了网络的性能。</p><p><strong>多路复用和解复用（功能上非常重要）</strong>：</p><blockquote><p>ip 是从主机到主机的。<strong>传输层引入 port 端口号区分为进程到进程</strong>。</p></blockquote><ul><li><strong>TCP</strong></li></ul><p><strong>源端</strong>：传输层从应用层拿下 message，然后添加 TCP 头部（包含源端口和目标端口），形成 TCP 的段</p><p>TCP 段同源 ip 目标 ip 再往下交，然后在 TCP 段前面加上 IP 头部（包括源 ip 和目标 ip），形成 IP 数据报。</p><p>借助网卡打出去。</p><p><strong>目标端</strong>：收到了以后，把 ip 的载荷部分（报文体）拿出来，然后得到 TCP 段。</p><p>根据 TCP 段的 TCP 头携带的端口信息，然后查表找到 socket，将 message 发送给应用进程</p><ul><li><strong>UDP</strong></li></ul><p><strong>源端</strong>：传输层从应用层拿下 message，socket 以及 &amp; cad 结构体（包含目标端的 ip+port），复用方法与上面类似。</p><p><strong>目标端</strong>：解复用与上面类似。</p><h1 id="无连接传输udp-用户数据报协议"><a class="anchor" href="#无连接传输udp-用户数据报协议">#</a> 无连接传输：UDP （用户数据报协议）</h1><p>在 IP 协议提供的服务上，没有增加额外的服务，只是增加了复用解复用。</p><p>同 IP 协议一样，是尽力而为的，不可靠：有可能收到的是乱序的，也有可能丢失。</p><p>无连接的，没有握手。经常被用于流媒体，DNS，SNMP 协议。适合实时多媒体应用和事务型应用。</p><blockquote><p>因为是无连接的，所以叫数据报。所以有 UDP 数据报，IP 也叫数据报</p></blockquote><p>** 如何改进 UDP，使其安全？** 应用层上增加可靠性，或应用特定的差错恢复。</p><p><strong>UDP 数据报的格式</strong>：</p><ol><li><p><strong>8 个字节的头部</strong>。头部包含源端口号（2 字节），目标端口号（2 字节），长度（2 字节，包含头部后的长度），校验和（2 字节，就是我们之前说的 EDC 差错控制编码）</p></li><li><p><strong>载荷部分</strong>。载荷部分比较大。</p></li></ol><p><strong>校验和</strong>：检验被传输的报文段的差错（如比特反转等）</p><p>发送方计算校验和，然后接收方独立另外计算校验和，并与发送方发来的校验和进行比对。</p><blockquote><p>如果没有通过校验，那么报文一定错误。如果通过了校验，那么报文一定是对的嘛？<strong>不一定</strong>。也有可能虽然变了，D 和 EDC 但恰好仍然符合差错控制编码关系。（<strong>这种传输错误，通过 EDC 无法检验</strong>）</p><p>注：这个<strong> D</strong> 不仅仅是指 UDP 的数据报，可能还包含 UDP 的头部，甚至 IP 的伪头部</p></blockquote><p><strong>发送端如何做 Check-Sum</strong>？</p><p>我们把这个 D 按照 16bit 的大小，切成小块。然后每一个小块中的 16bit 都代表一个整数。把这些整数加起来，进行处理，就形成了一个校验和。</p><p>累加时需要注意，进位应该回滚。然后最后<strong>取反码</strong>得到 EDC。</p><p><strong>接收端如何检验</strong>？</p><p>把收到的 D 按照 16bit 切块，不足的补 0，然后累加（进位需要回滚），然后把 EDC 也加进来。如果最后结果是 16bit 全 1，那么校验成功。</p><h1 id="可靠数据传输rdt的原理"><a class="anchor" href="#可靠数据传输rdt的原理">#</a> 可靠数据传输 RDT 的原理</h1><p><strong>传输层可靠数据传输</strong>：最常见的是传输层的 TCP 实现了可靠数据传输。有些网络在链路层或者网络层就实现了可靠数据传输（极少）</p><p>上层应用 sending process，receiving process（要求可靠的服务）。借助下层的服务实现（下层不可靠 UDT）</p><p><strong>如何向上层提供可靠服务</strong>？</p><p>本层与上层的接口 <code>rdt_send(), deliver_data()</code> ，本层和下层的接口 <code>udt_send(), rdt_rev()</code> 是原语形式</p><p><strong>渐进地解释可信数据传输 RDT 实现原理</strong>：</p><ol><li><p>假设底下的 channel 有两个特性：不出错，不丢失。那么这边的协议就不需要做任何处理。</p><blockquote><p>底层协议的不可靠性，决定了 RDT 实现协议的复杂性。底层越不可靠，RDT 越复杂。</p></blockquote></li><li><p>我们只考虑单项数据传输简化数据传输（虽然实际情况下是双向传输，但是双向传输是两个单向传输的综合）并尝试使用有限自动机来描述协议的原理。</p></li><li><p><strong>RDT 1.0</strong>：可靠信道上的可靠数据传输。什么都没干，只封装解封装。</p></li><li><p><strong>RDT 2.0</strong>：假设我们去掉不出错的特性（传输过程中，分组中的比特可能反转）保留不丢失特性。我们应该引入接收方的反馈机制。</p><blockquote><p>如果接受方接受到的 D 和 EDC 检验成功，向发送方返回 ACK；如果检验不成功，则返回 NAK。</p><p>因为接收方可能发送 NAK（即发送方可能发送失败）所以发送方需要有重传机制，即需要把发送完的东西放一个副本。</p><p>发送方：接收方返回 ACK 则发新的，接收方放回 NAK 或者不返回则发老的。（<strong>属于停止等待协议</strong>）</p></blockquote></li><li><p><strong>RDT 2.1</strong>：既然不满足不出错的特性，Package 可能出错，那么 ACK/NAK 也可能出错。那么怎么办呢。增加序号信息。</p><blockquote><p>如果 ACK/NAK 重复，那么直接重发。就算接收方收到重复也没关系，再发 ACK 就行了（此时接收序号 + 1）。发送端接收到 ACK 回应，那么就把发送序号 + 1</p><p>接收方等待 P1，到来的还是 P0（收到了重复的分组），且没出错（那肯定是接收端之前回传的 ACK 出问题了），那么接收方还要把 ACK 重新放一遍。（此时分组不向上传了，重复了，直接丢掉。）</p><p>【实际上】停止等待协议中，我们只需要区分老的分组和新的分组，只需要 1bit，就可以处理这个序号问题。</p></blockquote></li><li><p><strong>RDT 2.2</strong>：无 NAK 的协议。功能同<strong> RDT 2.1</strong> 但只使用 ACK 实现（NAK free）。但对 ACK 进行编号</p><blockquote><p>对当前分组的反向确认，用对前一功能的正向确认替代。比如我想要 P1，但发来的 P1 错了，或者发来的就是 P0，那么我继续发送 P0 的 ACK 确认。</p><p>为后面一次发送多个数据单位做准备。（一次发送多个 ACK/NAK 很麻烦。如果采用这种机制，可以使得信息确认减少一半，信息处理更加便捷）</p></blockquote></li><li><p><strong>RDT 3.0</strong>：假设我们把另一个特性也去掉，即 Package 也可能丢失。那么可能会引起死锁。<strong>引入超时重传机制</strong>。</p><blockquote><p>设计一个超时计时器，发送端发送完分组就启动。重传时间一般设置为比一次正常往返多一点。如果重传时间内，没有收到对应确认，那么就重发。（如果 P1 出问题，那么接收端返回的 ACK0，但是这时候发送端不马上重传，等一手超时重传）</p><p>反正<strong>所有的重传，都可以等超时重传</strong>。</p><p><strong>超时定时器重传时间设置是一个学问</strong>。如果设置不好，那么会有一个时间上的交错，导致 packet 和 ack 都要发两次，效率不高。</p><p>采用适应式的超时重传机制。</p></blockquote></li><li><p><strong>到此为止，对于停止等待型的 RDT，已经比较完备，能够对抗丢失和出错。</strong></p></li><li><p><strong>停止等待型在信道容量大时，效率比较低</strong>。比如北京到天津的告诉公路。如果只允许一辆车，确认到了以后，才发下一辆车，那么效率肯定低。</p><blockquote><p>端到端的延迟<strong> t=15ms</strong>，那么往返一次的时间<strong> RTT=2t=30ms</strong>（发送数据，返回确认），若分组长度<strong> L=1KB=8000bits</strong>，带宽<strong> R=1Gbps</strong>，那么分组的发送时间，就是<strong> L/R=8us</strong>，占了 30ms 的极小一部分。利用率 **u=8us/(8us+30ms)=0.027%** 非常低。</p><p>有效吞吐就很低<strong> 270kbps</strong>。利用率很低。<strong>问题在协议</strong>。这个协议一次只发一个。</p></blockquote></li><li><p><strong>流水线协议</strong>一次发送多个未经确认的分组。</p><blockquote><p>需要用多个 bit 表示分组序号</p><p>发送方需要缓冲区。以便于检错重发，或者超时重发。</p><p>接收方需要缓冲区。发送方的发送能力和接收方的处理能力有差距。所以需要缓冲区。</p></blockquote></li><li><p><strong>通用协议：滑动窗口协议 slide window 协议</strong></p><blockquote><p>send window = 1, receive window = 1 就是停止等待协议</p><p>send window &gt; 1, receive window = 1 就是 GBN 协议（属于流水线协议）</p><p>send window &gt; 1, receive window &gt; 1 就是选择重发协议（属于流水线协议）</p><p>发送窗口，是发送缓冲区的的子集，用于存放哪些已发送但是未确认的分组</p><ul><li>每发送一个分组，发送窗口的前沿，向前移动一格（但不能超过发送缓冲区大小）<ul><li>当发送窗口，把发送缓冲区已经占满，就不能发送了。</li></ul></li><li>收到老分组的确认，那么发送窗口的后沿，向前移动。（发送缓冲区也向前移动）发送缓冲区可以罩住新的分组，来了分组可以发送。<ul><li>后沿的向前移动，不能超过前沿。</li></ul></li></ul></blockquote></li><li><p>GBN 协议</p><blockquote><p>如果接收窗口只有 1 的大小。已经顺序接收了 012 三个分组，在等分组 3，此时来了分组 4，那么会返回 ACK2（确认最近到的，序号最大的分组）</p><p><strong>造成分组异常的因素有两点</strong>：1. 所传的分组在过程中出错或丢失。 2. 接收方给的确认，没有到达发送方。这两种都可能造成分组乱序到达。</p><p><strong>异常情况下 GBN 协议的窗口互动</strong>：（<strong>顺序确认</strong>）只有给出了新分组的确认，发送窗口才能向前滑动。如果超时，那么发送窗口会把所有已发送未确认的分组，全部重新再传一遍。</p><p><img data-src="Chapter-3-Transport-Layer/image-20220312112115643.png" alt="image-20220312112115643"></p></blockquote></li><li><p>选择重传协议。</p><blockquote><p>如果接收窗口有 5 的大小，那么哪个分组到来，就确认哪个分组。比如等待 01234（来 0，则发 ACK0，窗口前移），然后变成等待 12345（若来 2，则发送 ACK2 <strong>单独确认</strong>，但窗口不前移，因为 1 没到）。</p><p>如果此时 1 到来，发送 ACK1，然后 12 一起解封装向上传递，窗口前移两个。</p><p>如果 1 一直没到，那么 1 会超时，所以发送端要重新发送。因为已经收到了 2 的确认，所以不再传 2（选择重传）</p><p><img data-src="Chapter-3-Transport-Layer/image-20220312112357144.png" alt="image-20220312112357144"></p></blockquote></li><li><p>协议对比</p></li></ol><table><thead><tr><th></th><th>GBN</th><th>SR</th></tr></thead><tbody><tr><td>优点</td><td>简单，所需资源少（接收方一个缓存单元）</td><td>出错时重传一个，代价小</td></tr><tr><td>缺点</td><td>一旦出错，回退 N 步，代价大</td><td>复杂，所需资源多（接收方多个缓存单元）</td></tr><tr><td>适用范围</td><td>出错率低的场景使用，如果出错是罕见的，那么没有必要用 SR</td><td>链路容量大的场景适合用 SR（用 GBN 的话一点出错代价太大）</td></tr></tbody></table><ol start="15"><li><strong>思考</strong>：如果用 n 个 bit 来代表发送窗口的序号，GBN 发送窗口最大值是 $$2<sup n-1="">n-1$$，SR 协议的发送窗口最大值是 $$2</sup>$$. 为什么</li></ol><h1 id="面向连接的tcp"><a class="anchor" href="#面向连接的tcp">#</a> 面向连接的 TCP</h1><p>提供<strong>点对点的服务</strong>。（进程到进程，一个发送方，一个接收方）</p><p><strong>可靠的字节流的服务</strong>。（不出错，不重复，不丢失，不失序，原原本本）但不区分报文的界限。</p><p>是<strong>管道化、流水线的协议</strong>。在未经确认的情况下，可以发送很多连续的 TCP 段。</p><p><strong>存在发送缓冲区</strong>，要检错重发和超时重传；<strong>存在接收缓冲区</strong>，接收端的读取能力和线路的传送能力不匹配</p><p><strong>是全双工的</strong>。在同一连接中，数据可以同时、双向流动。</p><p><strong>面向连接</strong>，需要建立连接才能通信。</p><p>TCP 段的载荷部分<strong>存在一个最大报文大小 MSS</strong>。</p><blockquote><p>每一个物理网络都有一个 MTU 最大传输单元。以太网的 MTU=1500 Byte.</p><p>其中 IP 头部 20B，TCP 头部 20B，所以报文最大是 1460B。所以应用层交下来的字节流，需要按照 1460B 来切分。</p></blockquote><p><strong>TCP 报文段结构</strong>：</p><ul><li><p>16bit 源端口， 16bit 目标端口</p></li><li><p>32bit 序号（这个序号不是上面说的 PDU 的序号，而是 TCP body 的第一个字节，切分前在原字节流中的偏移量）</p></li><li><p>32bit 确认号（确认号也是以字节为单位的，如果发送方收到 ACK=555，那么代表，接收方已经接收到 554 及 554 以前的全部字节）确认号是累计确认的。</p></li><li><p>首部长度、保留未用的位，以及标志位 U,A,P,R,S,F（不同标志位组合，表示报文的不同功能类型），共 16bit ; 接收窗口 16bit（用于流量控制）。</p></li><li><p>校验和 16bit ；紧急数据指针 16bit（一般不用，是一个古老的字段）</p></li><li><p>可选项 32bit 也是属于头部。</p></li></ul><p><strong>接收方如何处理乱序的报文段</strong>？协议没有规定。</p><p><strong>简单 telnet 场景</strong>：</p><p>接收方，根据收到报文的 ACK 值，确定发出的段的序号。</p><p><img data-src="image-20220317222941995.png" alt="image-20220317222941995"></p><p><strong>怎样设置 TCP 的超时定时器</strong>？如果不合适，就会造成链路利用率低。</p><ul><li>必须要比 RTT 长，但 RTT 是变化的</li><li>如果太短，那么会过早超时重传，会传很多本不必要传的</li><li>如果太长，那么如果报文丢失，反应慢。</li></ul><p><strong>如何估计 RTT</strong>？</p><p>不是一个固定的值，而是一个适应式的测量计算。 TCP 的往返延迟随着时间变化非常的大，通信环境非常复杂。</p><p>应当定期去测量往返延迟。然后计算平均值 E，然后计算往返延迟的方差 D。取 RTT=R+4D。</p><p>我们会先收集一个 sample RTT（从发送方发出，到发送方接收到应答）。如果直接用 sample RTT 不合适。因为 sample RTT 会有较大的浮动。所以我们要不断去修正这个 RTT： <code>newE(RTT)= (1-a)prevE(RTT) + a * sampleRTT</code> 当前时间采样值对 RTT 的贡献越大。越往前的采样值，对 RTT 的贡献要越小，得到<strong>移动平均的 RTT</strong>。</p><p>我们再计算偏里程度 DevRTT： <code>newDevRTT = (1-b)prevDevRTT + b * |sampleRTT-newE(RTT)|</code></p><p><strong>TCP 的可靠数据传输</strong>：TCP 是 GBN 和 SR 的混合体，有些方面像 GBN，有些方面像 SR</p><p>TCP 在 IP 的基础上，建立了 RDT。是管道化的，且采取累计确认的机制（ACK 是表示期待，如 555，表示 555 之前的收到了，希望从 555 收开始接收）。</p><p><strong>像 GBN</strong>：发送方只设置一个定时器，不是为每个端都设置定时器（只和最老发出去的那个段相关联。）确认的时候，是对顺序到来的最后一个字节的确认。（最后一个字节 + 1 然后返回）</p><p><strong>像 SR</strong>：如果超时定时器超时，那么只重传最老的那个段，而不是把所有端都重传。</p><p>如果收到乱序报文段？TCP 协议没有规定处理方式。可以抛弃，也可以缓存。</p><p><strong>触发重发</strong>：超时定时器<strong>触发超时重传</strong>，收到了某些段的连续三个冗余确认（第一个正常确认不算）而<strong>触发快速重传</strong>；。</p><p><strong>TCP 发送事件</strong>：发送一段长度为 MSS 的报文后，发送窗口前沿移动 MSS 的单位，然后开启超时定时器。如果 TCP 发送端接收到一个 ACK 555，那么就把发送窗口的后沿，移动到 555。</p><p><strong>产生 TCP ACK 的建议</strong>：</p><ul><li><p>接收窗口，顺序接收到一个段，不建议直接法确认，而是建议启动辅助计时器。</p><ul><li>如果在这个计时器内，顺序的下一个段到，那么直接发送两个段的累计确认。</li><li>如果辅助计时器到了，顺序的下一个段还不来，那么赶紧确认，而发送方避免重传。</li></ul></li><li><p>接收窗口，乱序到了一个段，那么赶快把前面没收到的那个段的期待发给对方。让对方赶快补发这个段。</p></li><li><p>如果来了一个段，把 GAP 补齐（部分补齐，全部补齐）发送最后到达的连续分组的序号。</p></li></ul><p><strong>快速重传机制</strong>：如果 ACK 大于 BASE，那么滑动窗口后沿向前滑动。如果 ACK=BASE，就进行计数。如果连续收到 3 个冗余，那么就重发</p><hr><p><strong>流量控制</strong>：接收缓冲区。通过反馈空闲缓冲区的尺寸，达到流量控制的目的（捎带 Piggybacking）receive window 字段</p><p>什么是捎带？由于是全双工，所以既是接收方，也是发送方。我们不必为 ACK 专门浪费一个报文，可以在传输 data 的同时，携带对上一个报文的确认。</p><p><strong>两个重要变量</strong>：</p><ul><li>lastByteRead 上一个被读的字节</li><li>lastByteRcvd 上一个被接收的字节</li></ul><p>相减计算得到 RcvBuffer 接收缓冲区大小</p><hr><p><strong>TCP 连接建立：三次握手</strong></p><ol><li>客户端向服务器发送连接请求报文（SYNbit=1 代表连接请求，选择 seq=x 是报文初始序号）</li><li>服务端向客户端返回（SYNbit=1，ACKbit=1，ACKnum=x+1，seq=y）</li><li>客户端向服务器发送确认（ACKbit=1，ACKnum=y+1 希望服务器从 y+1 开始发，即 y 已经收到）</li></ol><blockquote><p><strong>异常情况</strong>：如果 TCP 只采用两次握手，则会产生大量的半连接（半连接只在服务器端维护的连接，可能是由于超时重传引起的）服务器还会将老的数据（重传的数据）当做新数据接收。</p><p>三次握手的话，如果产生超时重传，客户端就会把连接关掉（不会产生半连接）。</p><p>有可能产生老数据当新数据接收的情况。但只要初始的 seq 不同，这个几率几乎为零。</p><p><strong>初始序号的选择</strong>：客户端和服务器可以根据时钟周期选择初始序号。比如，当前时间，取低 32 位作为初始序号。</p></blockquote><p><strong>TCP 连接关闭和释放：四次挥手</strong></p><p>需要双方各自拆除连接。但这个连接拆除<strong>是不可靠的</strong></p><p>客户端要向服务器发起拆除，服务器返回拆除确认</p><p>服务器也要向客户端发起拆除，然后客户端返回拆除确认</p><h1 id="拥塞控制原理"><a class="anchor" href="#拥塞控制原理">#</a> 拥塞控制原理</h1><p><strong>拥塞的原因（场景化描述）/ 代价</strong>：</p><ol><li><p>2 个发送端，2 个接收端，一个路由器缓冲无限大，输出链路的带宽为 R，没有重传。</p><blockquote><p><strong>网络中的数据，超出网络处理能力了，就会拥塞。</strong></p><p>延迟特别大。比在不拥塞的时候，延迟大很多。</p></blockquote></li><li><p out="">一个路由器，有限的缓冲，分组丢失时，发送方应当重传。路由器输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\lambda_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，路由器输出\lambda_</p><blockquote><p>【理想化】发送端有完美的信息。发送端知道什么时候路由器的缓冲区可用。只在缓冲区可用的时候发送，这样分组就不会丢失。</p><p>【理想化】掌握丢失信息。分组可以丢失（路由器发送缓冲区满而被丢弃）如果知道分组丢失了，那么发送方重传分组。随着拥塞情况的不断增加（重传的分组增加）所以，传输效率会降低。（输出比输入少。因为重传了丢失分组和没有必要重传的分组）</p></blockquote></li></ol><p>​	<strong>拥塞代价</strong>：发出许多没有必要重传的分组。（许多分组只是由于拥塞，而超出了超时定时器，并不是因为丢失）</p><ol start="3"><li><p>4 个发送端，多重路径，超时重传</p><blockquote><p>拥塞时，路由器的空闲缓冲区大小总是 0 或 1</p><p>拥塞造成死锁，而且会丢包。</p><p>【代价】当分组丢失时，任何的 “关于这个分组的上游传输能力” 都被浪费了。（前面传的都白传了）</p></blockquote></li></ol><p><strong>拥塞控制方法</strong>：</p><ul><li><p>端到端的拥塞控制</p><blockquote><p>没有来自网络的显式反馈</p><p>端系统根据延迟和丢失时间推断是否有拥塞</p><p>TCP 采用这种方法。</p></blockquote></li><li><p>网络辅助的拥塞控制</p><blockquote><p>路由器向端系统提供反馈信息</p><p>显示提供发送端可以采用的速率</p><p>单个 bit 置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM）</p><p>【例】ATM 的 ABR 拥塞控制 available bit rate</p><ul><li>弹性服务：<ul><li>如果发送端的路径 “轻载”，那么发送方可以使用全部带宽</li><li>如果发送方的路径拥塞了，那么发送方限制其发送速度到一个最小的保障速率上来</li></ul></li></ul><p>RM（资源管理）信元</p><ul><li>信元是 ATM 网络中传递的基本单元。在若干个数据信元之中，就会间隔插入一个 RM 信元</li><li>RM 信元中的比特被交换机设置。（网络辅助就体现在这里）<ul><li>如果发生轻微拥塞，就把 NI 这个 bit 位置 1（no increase in rate）轻微拥塞，速率不要增加了</li><li>如果发生拥塞，则 CI bit 置 1（congestion indication）</li><li>ER 字段（explicit rate）体现了所有交换设备的瓶颈带宽（短板效应），防止拥塞。拥塞的交换机会改变 ER 字段的值。</li></ul></li><li>数据信元的 EFCI bit 位：如果 RM 前的那个数据信元，EFCI bit = 1，那么接收端在返回的 RM 中，将 CI bit 设置为 1</li><li>发送端发送的 RM 信元被接收端返回，接收端不做任何改变。直到 RM 信元被发送端重新接收</li></ul></blockquote></li></ul><h1 id="tcp拥塞控制"><a class="anchor" href="#tcp拥塞控制">#</a> TCP 拥塞控制</h1><p>端到端，网络不提供任何辅助信息。网络辅助拥塞控制的代价太大。</p><p><strong>发送端如何探测到拥塞</strong>？</p><ol><li>某个段超时了（或丢失了）：拥塞<ul><li>超时时间到，某个段的确认还没有来</li><li>原因 1：网络拥塞，某个路由器的缓冲区没有空间了，被丢弃（概率大）</li><li>原因 2：出错被丢弃（各级错误，没有通过校验，被丢弃）（概率小）</li><li>一旦超时，就认为是拥塞了，虽然有一定误判，但是总体方向是对的</li></ul></li><li>有关某个段的三次重复冗余 ACK：轻微拥塞<ul><li>段的第一个 ACK 是正常 ACK</li><li>段的第 2,3,4 个 ACK 是冗余 ACK，说明乱序到达。（后面三个段都到了，但是目标段还没到，丢失的可能性很大）</li><li>这时候，网络还能进行一定的传输，拥塞情况比第一种要好。</li></ul></li></ol><p><strong>速率控制的方法</strong>：</p><p>维持一个拥塞窗口值 CongWin（这个值是动态的，是感知到的网络拥塞程度的函数）</p><ul><li>如果超时，或者有 3 个重复、冗余 ACK，那么 CongWin 下降。<ul><li>超时时，CongWin 降为 1MSS，进入 SS 阶段然后再倍增到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{CongWin}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.924439em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:.03588em">g</span><span class="mord mathnormal mtight" style="margin-right:.13889em">W</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（每个 RTT），从而进入 CA 阶段</li><li>3 个重复 ACK，CongWin 降到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>W</mi><mi>i</mi><mi>n</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{CongWin}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.924439em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:.03588em">g</span><span class="mord mathnormal mtight" style="margin-right:.13889em">W</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（每个 RTT），处于 CA 阶段</li></ul></li><li>如果没有以上情况，那么 CongWin 跃跃欲试（上升）<ul><li>SS 阶段（慢启动阶段）：加倍增加（每个 RTT）</li><li>CA 阶段（拥塞避免阶段）：线性增加（每个 RTT）</li></ul></li></ul><p>发送端限制已发送，但未确认的数据量（的上限）</p><p>从而粗略地控制发送方往网络中注入的速率</p><p rtt="">rate =\frac{CongWin}</p><p><strong>TCP 的拥塞控制和流量控制联合作用</strong>：</p><p congwin,="" recvwin="">发送端控制发送但是未确认的量的同时，也不能超过接收窗口。需要满足流量控制的要求：SendWin=min</p><p><strong>TCP 拥塞控制策略概述</strong>：</p><p>慢启动</p><ul><li><p>连接刚建立 CongWin = 1 MSS</p><blockquote><p>如 MSS = 1460bytes; RTT = 200 msec</p><p>初始速率 = 58.4kbps（非常小，必须要想办法扩大）</p></blockquote></li><li><p>每收到一个确认，拥塞窗口值 + 1，这样一来，每个 RTT，拥塞窗口就加倍了。</p></li></ul><p>AIMD：线性增，乘性减少</p><ul><li>CongWin 的测试原理，从 1 开始，依次 2,4,8,16（在 16 处拥塞，即超时了）。然后乘性减少，将 8 作为警戒值。</li><li>第二次测试：还是从 1 开始，进入慢启动状态，依次 2,4,8，然后进入拥塞避免阶段，开始线性增加，依次 9,10,11,12（在 12 处拥塞，即超时了）。随后乘性减少，将 6 作为警戒值。</li><li>第三次测试：还是从 1 开始，进入慢启动状态，依次 2,4,6（达到警戒值），然后进入拥塞避免阶段，开始线性增加，依次 7,8,9,10（在 10 处，收到连续 3 个冗余 ACK）。随后乘性减少，将 5 作为警戒值</li><li>第四次测试：从 5 开始（由于上一次是连续三个冗余 ACK，属于轻微拥塞），直接进入拥塞避免阶段，依次 6,7,8, ......</li></ul><p>超时事件后的保守策略</p><blockquote><p>【总结】阈值 threshold，拥塞窗口：CongWin</p><p>CongWin 小于 threshold 时，处于慢启动状态（SS 阶段），窗口指数增长</p><p>CongWin 大于 threshold 时，处于拥塞避免状态（CA 阶段），窗口线性增长</p><p>当收到三个重复的 ACK 时，threshold 设置成 CongWin/2，然后 CongWin 设置成 threshold+3（为什么是 + 3，因为 3 个冗余 ACK）</p><p>超时事件 timeout 发生时候，threshold 设置成 CongWin/2，然后 CongWin 设置为 1MSS，进入慢启动阶段（SS 阶段）</p></blockquote><p><strong>TCP 吞吐量</strong>：</p><p>平均的窗口尺寸：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>W</mi><mo>+</mo><mfrac><mi>W</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mi>W</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}(W+\frac{W}{2})=\frac{3}{4}W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span></p><p>平均吞吐量（RTT 时间吞吐<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mn>4</mn></mfrac><mi>W</mi></mrow><annotation encoding="application/x-tex">\frac{3}{4}W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>）即吞吐量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mn>4</mn></mfrac><mo separator="true">⋅</mo><mfrac><mi>W</mi><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{4}·\frac{W}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.00773em">R</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> bytes/sec</p><p><strong>TCP 公平性</strong>：</p><p>n 个主机对，共享瓶颈带宽 R，长期来看，会均分共享，每一对主机对，获得 R/n 的带宽。</p><p>但 UDP 存在很强的侵略性。多媒体应用通常是 UDP，会侵占 TCP 进程的带宽。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-18 20:44:06" itemprop="dateModified" datetime="2022-10-18T20:44:06+08:00">2022-10-18</time> </span><span id="computer-science/computer-networks/Chapter-3-Transport-Layer/" class="item leancloud_visitors" data-flag-title="Chapter 3 Transport Layer" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sunforge 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Sunforge 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Sunforge 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Sunforge <i class="ic i-at"><em>@</em></i>鑄日</li><li class="link"><strong>本文链接：</strong> <a href="http://blog.sunforge.cn/computer-science/computer-networks/Chapter-3-Transport-Layer/" title="Chapter 3 Transport Layer">http://blog.sunforge.cn/computer-science/computer-networks/Chapter-3-Transport-Layer/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/computer-networks/Chapter-2-Application-Layer/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipesng5oej20zk0m87d4.jpg" title="Chapter 2 Application Layer"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>Chapter 2 Application Layer</h3></a></div><div class="item right"><a href="/computer-science/computer-networks/Chapter-4-The-Network-Layer-Data-Plane/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicliierfjj20zk0m8npd.jpg" title="Chapter 4 The Network Layer: Data Plane"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>Chapter 4 The Network Layer: Data Plane</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">传输层原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">概述和传输层服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93udp-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">无连接传输：UDP （用户数据报协议）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93rdt%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">可靠数据传输 RDT 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84tcp"><span class="toc-number">5.</span> <span class="toc-text">面向连接的 TCP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">拥塞控制原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">TCP 拥塞控制</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/computer-networks/Chapter-1-Computer-Networks-and-the-Internet/" rel="bookmark" title="Chapter 1 Computer Networks and the Internet">Chapter 1 Computer Networks and the Internet</a></li><li><a href="/computer-science/computer-networks/Chapter-2-Application-Layer/" rel="bookmark" title="Chapter 2 Application Layer">Chapter 2 Application Layer</a></li><li class="active"><a href="/computer-science/computer-networks/Chapter-3-Transport-Layer/" rel="bookmark" title="Chapter 3 Transport Layer">Chapter 3 Transport Layer</a></li><li><a href="/computer-science/computer-networks/Chapter-4-The-Network-Layer-Data-Plane/" rel="bookmark" title="Chapter 4 The Network Layer: Data Plane">Chapter 4 The Network Layer: Data Plane</a></li><li><a href="/computer-science/computer-networks/Chapter-5-The-Network-Layer-Control-Plane/" rel="bookmark" title="Chapter 5 The Network Layer: Control Plane">Chapter 5 The Network Layer: Control Plane</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sunforge" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sunforge</p><div class="description" itemprop="description">计科人笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">18</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">5</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JFQVRJTkctSEVBUlQ=" title="https:&#x2F;&#x2F;github.com&#x2F;BEATING-HEART"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmJlYXRpbmdfaGVhcnRAeWVhaC5uZXQ=" title="mailto:beating_heart@yeah.net"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>魔盒</a><ul class="submenu"><li class="item"><a href="/webstack/" rel="section"><i class="ic i-star"></i>网址</a></li><li class="item"><a href="/books/" rel="section"><i class="ic i-clipboard"></i>书架</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/computer-networks/Chapter-2-Application-Layer/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/computer-networks/Chapter-4-The-Network-Layer-Data-Plane/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/hexo/" title="分类于 Hexo 博客">Hexo 博客</a></div><span><a href="/computer-science/hexo/%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BD%BF%E7%94%A8Pure%E4%B8%BB%E9%A2%98%EF%BC%89%E5%B9%B6%E6%89%98%E7%AE%A1%E5%88%B0Github-Page/" title="用Hexo搭建个人博客（使用Pure主题）并托管到Github Page">用Hexo搭建个人博客（使用Pure主题）并托管到Github Page</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" title="分类于 强化学习">强化学习</a></div><span><a href="/computer-science/reinforcement-learning/index/" title="强化学习：索引">强化学习：索引</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/git/" title="分类于 git">git</a></div><span><a href="/computer-science/git/%E9%85%8D%E7%BD%AEgithub%E7%9A%84ssh-key/" title="配置github的ssh key (Windows)">配置github的ssh key (Windows)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-networks/Chapter-2-Application-Layer/" title="Chapter 2 Application Layer">Chapter 2 Application Layer</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-networks/Chapter-5-The-Network-Layer-Control-Plane/" title="Chapter 5 The Network Layer: Control Plane">Chapter 5 The Network Layer: Control Plane</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/computer-science/computer-networks/Chapter-3-Transport-Layer/" title="Chapter 3 Transport Layer">Chapter 3 Transport Layer</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/" title="分类于 回归模型">回归模型</a></div><span><a href="/computer-science/machine-learning/linear-regression/" title="机器学习：线性回归">机器学习：线性回归</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99/" title="分类于 基本法则">基本法则</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99/%E6%95%B0%E5%AD%A6/" title="分类于 数学">数学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/" title="分类于 凸优化">凸优化</a></div><span><a href="/fundamental/math/convex-optimization/index/" title="凸优化：索引">凸优化：索引</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="分类于 机器学习">机器学习</a></div><span><a href="/computer-science/machine-learning/index/" title="机器学习：索引">机器学习：索引</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/hexo/" title="分类于 Hexo 博客">Hexo 博客</a></div><span><a href="/computer-science/hexo/%E4%BD%BF%E7%94%A8Github%E7%AE%A1%E7%90%86Hexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B9%B6%E9%85%8D%E7%BD%AEGithub-Action%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2/" title="通过Github管理Hexo博客源码，并配置Github Action自动编译部署">通过Github管理Hexo博客源码，并配置Github Action自动编译部署</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sunforge @ Sunforge</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">124k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:53</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/computer-networks/Chapter-3-Transport-Layer/",favicon:{show:"但你不会停止思考，对吗？",hide:"这个世界真复杂啊 | Sunforge"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>